#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

 typedef struct {
  int a;
  int b;
  int result;
  int result2;
  int use_count;
  int use_count2;
  int max_use;
  int max_use2;
} app_data;


void *user_thread(void *data)
{
	 int uses=0;
	 app_data *td=(app_data*)data;
	 while(uses<td->max_use)
	 {
		 if (td->a==5)
		 {
			 td->result+=(td->a+td->b);
			 td->use_count++;
			 uses++;
		 }
		 usleep(1);							//usleep is used to make sure the scheduler gives other threads a chance to run
	 }
	 return 0;
}

void *changer_thread(void *data)
{
	 app_data *td=(app_data*)data;
	 while ((td->use_count+td->use_count2)<(td->max_use+td->max_use2))
	 {
		 if (td->a==5)
		 {
			 td->a=50;
			 td->b=td->a+usleep(1000);		//fake a CPU-intensive calculation for a with a usleep(1000) call
		 }
		 else
		 {
			 td->a=5;
			 td->b=td->a+usleep(1000);		//fake a CPU-intensive calculation for b with a usleep(1000) call
		 }
		 usleep(1);							//usleep is used to make sure the scheduler gives other threads a chance to run
	 }
	 return 0;
}

int main(int argc, char *argv[])
{
	printf("Welcome to the QNX Momentics IDE\n");

	pthread_t ct,ut,st;
	app_data td={5,5,0,0,0,0,100,0};
	void *retval;

	pthread_create(&ut,NULL,user_thread,&td);
	pthread_create(&ct,NULL,changer_thread,&td);

	// wait for all threads to finish
	pthread_join(ct,&retval);
	pthread_join(ut,&retval);

	// print results
	printf("result should be %d, is %d\n",td.max_use*(5+5),td.result);

	printf("\nMain Terminating....");
	return EXIT_SUCCESS;
}
