#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/dispatch.h>

#define ATTACH_POINT "CTC"
#define BUF_SIZE 100
typedef union{
	union{
		_Uint32t sival_int;
		void *sival_ptr;
	};
	_Uint32t dummy; // dummy variable to create space
}_customSignalValue;

typedef struct _CustomPulse{ // Override the standard struct _pulse msg_header_t
	_Uint16t type;
	_Uint16t subtype;
	_Int8t code;
	_Uint8t zero[3]; // same padding used in standard struct _pulse
	_customSignalValue value;
	_Uint8t zero2[2]; // added extra padding for enduring alignment access
	_Int32t serverConnectionId;
}msg_header_t;

typedef struct {
	msg_header_t header;
	int clientId;
	int data;
}messageData;

typedef struct {
	msg_header_t header;
	char buf[BUF_SIZE];
} replyData;

typedef struct {
	int receiveId;
	int messageNum;
	int stayAlive;
	int isLiving;
}serverParam;

int server();

int main(int argc, char *argv[]){
	puts("Central Traffic Controller Running...");
	int returnedValue = server();
	puts("Central Traffic Controller Terminated");
	return returnedValue;
}

void replyDataInit(replyData *data, _Uint16t type, _Uint16t subtype){
	data->header.type = type;
	data->header.subtype = subtype;
}

void serverParamInit(serverParam *param){
	param->receiveId = 0;
	param->messageNum = 0;
	param->stayAlive = 0;
	param->stayAlive = 0;
}

int server(){
	printf("_customSignalValue = %d bytes\n", sizeof(_customSignalValue));
	printf("msg_header_t = %d bytes\n", sizeof(msg_header_t));
	printf("messageData = %d bytes\n", sizeof(messageData));
	printf("replyData = %d bytes\n", sizeof(replyData));

	name_attach_t *attachName;
	messageData message;
	replyData reply;
	serverParam sp;

	replyDataInit(&reply, 0x01, 0x00);
	serverParamInit(&sp);

	attachName = name_attach(NULL, ATTACH_POINT, 0); // creating a global name which is located in /dev/<hostname>/local/<ATTACH_POINT>
	if(attachName == NULL){
		// if name is not attached successfully exit the program early
		printf("ERROR: Failed to compute name_attach on ATTACH_POINT: %s\n", ATTACH_POINT);
		printf("----> Another server may run the same ATTACH_POINT name or GNS service has not yet started");
		return EXIT_FAILURE;
	}

	printf("CTC Listening for L1, and L2 on ATTACH_POINT: %s\n", ATTACH_POINT);
	sp.isLiving = 1; // set thread status that it is living as connection has been made;
	while(sp.isLiving){
		sp.receiveId = MsgReceive(attachName->chid, &message, sizeof(message), NULL);
		if(sp.receiveId == -1){
			// break the loop early if there is no received message Id returned from MsgReceive
			printf("ERROR: Failed to receive message from MsgReceive\n");
			break;
		}
	}

	return EXIT_SUCCESS;
}
