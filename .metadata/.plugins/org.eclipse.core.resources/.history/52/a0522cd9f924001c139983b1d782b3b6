#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <sys/dispatch.h>
#include <pthread.h>
#include <sys/syspage.h>
#include <unistd.h>
#include <sys/select.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <stdbool.h>

#define COLOR_CODE_SIZE 2
#define ATTACH_POINT_TC "TC"
#define BUF_SIZE 100

enum states {
	state0, state1, state2, state3, state4, state5, state6
};

typedef union{
	union{
		_Uint32t sival_int;
		void *sival_ptr;
	};
	_Uint32t dummy[4];
}_CustomSignalValue;

typedef struct _CustomPulse{
	_Uint16t type;
	_Uint16t subtype;
	_Int8t code;
	_Uint8t zero[3];
	_CustomSignalValue value;
	_Uint8t zero2[2];
	_Int32t serverConnectionId;
}msg_header_t;

typedef struct {
	int name[BUF_SIZE];
	int id;
	int waitTime;
	int living;
	char message[BUF_SIZE];
	char color[COLOR_CODE_SIZE];
} TrafficLightSettings;

typedef struct {
	msg_header_t header;
	TrafficLightSettings trafficLight;
}MessageData;
typedef struct{
	msg_header_t header;
	int clientId;
	volatile char data;
	int instructionReady;
}InstructionCommand;
typedef struct {
	msg_header_t header;
	char buf[BUF_SIZE];
	char replySourceName[BUF_SIZE];
}ReplyData;

typedef struct {
	MessageData message;
	ReplyData reply;
	InstructionCommand instruction;
	pthread_mutex_t mutex;
	pthread_cond_t condVar;
	name_attach_t *attach;
	enum states currentState;
	int dataIsReady;
}SensorData;
void pulseStateMachine(InstructionCommand instruction, int stayAlive, int messageNum){
	printf("----> CTC Received a pulse from ClientID(%d)\n", instruction.clientId);
	printf("----> Received Message Header Code: %d\n", instruction.header.code);
	switch(instruction.header.code){
	case _PULSE_CODE_DISCONNECT:
		printf("Pulse STATUS CODE: %d\n", _PULSE_CODE_DISCONNECT);
		if(stayAlive == 0){
			// if received pulse to disconnect => disconnect all its connection by running name_close
			// for each name_open()
			ConnectDetach(instruction.header.serverConnectionId); // pass serverConnectionId to detach
			printf("Detaching: Server is requested to detach from ClientId(%d)\n", instruction.clientId);
		}else{
			printf("Rejected: Server is requested to detach from ClientId(%d) but rejected\n", instruction.clientId);
		}
		break;
	case _PULSE_CODE_UNBLOCK: // receiveId associated with the blocking instruction
		// Gives the option to reply back to the client now or later after being hit by a signal or a time out
		printf("\nServer Received: _PULSE_CODE_UNBLOCK after %d messages\n", messageNum);
		break;
	case _PULSE_CODE_COIDDEATH: // Received an ID of a connection that was attached to a destroyed channel
		printf("\nServer Received: _PULSE_CODE_COIDDEATH after %d messages\n", messageNum);
		break;
	case _PULSE_CODE_THREADDEATH: // Received an ID of a thread that just died
		printf("\nServer Received: _PULSE_CODE_THREADDEATH after %d messages\n", messageNum);
		break;
	default:
		printf("\nServer Received: Unrecognized pulse detected after %d messages\n", messageNum);
		break;
	}
}
// This thread will listen to CTCT regarding the given input or key pressed from Central Controller
// Those key press will determine changes of sequences of the traffic light system
void *server(void *data){
	SensorData *sd = (SensorData*)data;
	int receiveId = 0, serverConnectionId = 0;
	int messageNum = 0, stayAlive = 0;
	if((sd->attach = name_attach(NULL, ATTACH_POINT_TC, 0))==NULL){
		// if name is not attached successfully exit the program early
		printf("ERROR: Failed to compute name_attach on ATTACH_POINT_TC: %s\n", ATTACH_POINT_TC);
		printf("----> Another server may run the same ATTACH_POINT_TC name or GNS service has not yet started");
		return EXIT_FAILURE;
	}
	printf("THREAD STARTING: %s server thread is starting...\n", ATTACH_POINT_TC);
	printf("TC Listening for CTC ATTACH_POINT_TC: %s\n", ATTACH_POINT_TC);

	pthread_mutex_lock(&sd->mutex);
	living = 1;
	while(living){
		while(sd->instruction.instructionReady){
			pthread_cond_wait(&sd->condVar, &sd->mutex);
		}
		receiveId = MsgReceive(sd->attach->chid, &sd->instruction, sizeof(sd->instruction), NULL);

		if(receiveId == -1){
			// break the loop early if there is no received message Id returned from MsgReceive
			printf("ERROR: Failed to receive message from MsgReceive\n");
			break;
		}

		if(receiveId == 0){
			pulseStateMachine(sd->instruction, stayAlive, messageNum);
		}
	}
	pthread_mutex_unlock(&sd->mutex);
	return 0;
}
int main(void) {
	SensorData sensor;
	pthread_t tcThread;

	return EXIT_SUCCESS;
}
